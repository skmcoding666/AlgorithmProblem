package leetcode.difficult;

import util.TimeUtil;

import java.util.ArrayList;
import java.util.List;

/**
 * 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
 *
 * 你需要按照以下要求，帮助老师给这些孩子分发糖果：
 *
 * 每个孩子至少分配到 1 个糖果。
 * 相邻的孩子中，评分高的孩子必须获得更多的糖果。
 * 那么这样下来，老师至少需要准备多少颗糖果呢？
 *
 * 示例 1:
 * 输入: [1,0,2]
 * 输出: 5
 * 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
 *
 * 示例 2:
 * 输入: [1,2,2]
 * 输出: 4
 * 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
 *      第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
 *
 */

public class Solution135 {

    private static int[] mockRatings = {12000,11999,11998,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,1199011997,11996,11995,11994,11993,11992,11991,11990,11997,11996,11995,11994,11993,11992,11991,11990};

    public static void main(String[] args) {
        System.out.println(new TimeUtil().CalculationTime("My approach", candy_overTime(mockRatings)));
        System.out.println(new TimeUtil().CalculationTime("Official approach", candy(mockRatings)));
    }

    // 官方解法,真的强,贪心+2次遍历
    // 左遍历+贪心 -> 只看是否大于左边的值,获取从左到右的最低的糖果数
    // 右遍历+贪心 -> 只看是否大于右边的值,获取从右到左的最低的糖果数
    // 再获取每个下标的 Max(左遍历, 右遍历) -> 即满足左遍历,也满足右遍历的最低的糖果数 = 题目要求
    private static int candy(int[] ratings) {
        int n = ratings.length;
        int[] left = new int[n];
        // 首先生成左遍历数组
        for (int i = 0; i < n; i++) {
            if (i > 0 && ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            } else {
                left[i] = 1;
            }
        }
        // 右遍历直接将值存在 right 变量中,遍历的同时,将最大值加入 ret 中
        int right = 0, ret = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (i < n - 1 && ratings[i] > ratings[i + 1]) {
                right++;
            } else {
                right = 1;
            }
            ret += Math.max(left[i], right);
        }
        return ret;
        // 例: {5, 7, 8, 3, 4, 2, 1}
        // 左遍历数组: {1, 2, 3, 1, 2, 1, 1}
        // 右遍历数组: {1, 1, 2, 1, 3, 2, 1}
        // 取两边最大: {1, 2, 3, 1, 3, 2, 1} -> ret = 13
    }

    // 思路诡异: 遍历数组,每次挑出不大于左边也不大于右边的,即可确定其获得的糖果数,每次遍历结束后删除确定糖果数的元素,但要留下其位置
    // 但是!!!超时了!!!
    private static int candy_overTime(int[] ratings) {
        int result = 0;
        // 保存还未确定糖果数的元素的下标值
        List<Integer> index = new ArrayList<>();
        for(int i = 0; i < ratings.length ;i++) {
            index.add(i);
        }
        // 当前糖果数
        int tempAdd = 1;
        while(index.size() > 0) {
            // 遍历过程中删除元素会导致报错,所以要删除的元素先存储在list中
            List<Integer> deleteList = new ArrayList<>();
            for(int i: index) {
                // 第一个元素特殊处理
                if(i == 0) {
                    if(!index.contains(1) || ratings[i] <= ratings[1]) {
                        result += tempAdd;
                        deleteList.add(i);
                    }
                    // 最后一个元素特殊处理
                } else if(i == ratings.length - 1) {
                    if(!index.contains(i-1) || ratings[i] <= ratings[i-1]) {
                        result += tempAdd;
                        deleteList.add(i);
                    }
                    // 如果两边都已经确定了,说明当前元素也能确定了
                } else if(!index.contains(i-1) && !index.contains(i+1)) {
                    result += tempAdd;
                    deleteList.add(i);
                    // 如果左边确定了,而且小于等于右边,也能确定
                } else if(!index.contains(i-1) && ratings[i] <= ratings[i+1]) {
                    result += tempAdd;
                    deleteList.add(i);
                    // 如果右边确定了,而且小于等于左边,也能确定
                } else if(!index.contains(i+1) && ratings[i] <= ratings[i-1]) {
                    result += tempAdd;
                    deleteList.add(i);
                    // 如果同时小于等于两边,也能确定
                } else if(ratings[i] <= ratings[i-1] && ratings[i] <= ratings[i+1]) {
                    result += tempAdd;
                    deleteList.add(i);
                }
            }
            // 最后删除所以能确定的元素
            index.removeAll(deleteList);
            // 当前糖果数++
            tempAdd++;
        }
        return result;
    }
}

